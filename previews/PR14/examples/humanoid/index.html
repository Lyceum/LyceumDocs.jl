<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Creating a MuJoCo Environment · Lyceum</title><link rel="canonical" href="https://docs.lyceum.ml/dev/examples/humanoid/index.html"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Lyceum</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../MPPI/">Running a simple controller</a></li><li><a class="tocitem" href="../NPG/">Learning a control policy</a></li><li><a class="tocitem" href="../visualize/">Visualizing Results</a></li><li class="is-active"><a class="tocitem" href>Creating a MuJoCo Environment</a><ul class="internal"><li><a class="tocitem" href="#Humanoid-Type-1"><span>Humanoid Type</span></a></li><li><a class="tocitem" href="#Customizing-1"><span>Customizing</span></a></li><li><a class="tocitem" href="#Lyceum-API-Simple-Setup-1"><span>Lyceum API Simple Setup</span></a></li><li><a class="tocitem" href="#Running-Experiments-1"><span>Running Experiments</span></a></li><li><a class="tocitem" href="#Checking-Results-1"><span>Checking Results</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Creating a MuJoCo Environment</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Creating a MuJoCo Environment</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Lyceum/LyceumDocs.jl/blob/master/docs/src/examples/humanoid.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><div class="admonition is-info"><header class="admonition-header">Running examples locally</header><div class="admonition-body"><p>This example and more are also available as Julia scripts and Jupyter notebooks.</p><p>See <a href="https://github.com/Lyceum/LyceumDocs.jl/blob/master/example_howto.md">the how-to page</a> for more information.</p></div></div><h1 id="Creating-a-MuJoCo-Environment-1"><a class="docs-heading-anchor" href="#Creating-a-MuJoCo-Environment-1">Creating a MuJoCo Environment</a><a class="docs-heading-anchor-permalink" href="#Creating-a-MuJoCo-Environment-1" title="Permalink"></a></h1><p>Using Mujoco, we can create an environment that mostly relies on the defaults of LyceumBase and LyceumMuJoCo to propagate state, action, and observation data. We will have to include a reward and evaluation function, of course, and also show how the functions can be customized for different tasks.</p><p>First we grab our dependencies of the Lyceum ecosystem and other helpful packages</p><pre><code class="language-">using LinearAlgebra, Random, Statistics, UnicodePlots, JLSO
using LyceumBase, LyceumAI, LyceumMuJoCo, MuJoCo, UniversalLogger, Shapes
using LyceumBase.Tools
using Shapes: AbstractVectorShape
import LyceumBase: tconstruct
using Plots</code></pre><h2 id="Humanoid-Type-1"><a class="docs-heading-anchor" href="#Humanoid-Type-1">Humanoid Type</a><a class="docs-heading-anchor-permalink" href="#Humanoid-Type-1" title="Permalink"></a></h2><p>This struct is our primary entry into the environment API. As you can see, this simple example only wraps around the underlying simulator. The functions of the LyceumBase API will dispatch on this struct. When an algorithm calls a function such as <code>getobs!</code>, Julia will select from all functions with that name depending on the <em>type</em> of environment that is passed in.</p><pre><code class="language-">struct Humanoid{S} &lt;: AbstractMuJoCoEnvironment
    sim::S
end</code></pre><p>The following lines facilliatate construction of the simulation such that multi-threading performance is enabled; we will construct multiple instances of MuJoCo mjData structures which at run time will share the same mjModel struct. Primarily, this points to the xml file and how many mujoco timesteps to skip when doing steps at the environment level.</p><pre><code class="language-julia">Humanoid() = first(tconstruct(Humanoid, 1))
function tconstruct(::Type{Humanoid}, n::Integer)
    modelpath = joinpath(@__DIR__, &quot;humanoid.xml&quot;)
    Tuple(Humanoid(s) for s in tconstruct(MJSim, n, modelpath, skip=2))
end;</code></pre><h2 id="Customizing-1"><a class="docs-heading-anchor" href="#Customizing-1">Customizing</a><a class="docs-heading-anchor-permalink" href="#Customizing-1" title="Permalink"></a></h2><p>The following are helpers for the tasks we&#39;d like to consider. We want the humanoid to stand up, thus we need to grab the model&#39;s height, as well as record a laying down position that we can use to set the state to. By exploring the model in the REPL or xml we can see that qpos[3] is the index for the z-axis (height) of the root joint. The LAYING_QPOS data was collected externally by posing the model into a supine pose; one can use <code>simulate.cpp</code> included with a MuJoCo release to do this, if desired, or use LyceumMuJoCoViz as well.</p><pre><code class="language-">_getheight(shapedstate::ShapedView, ::Humanoid) = shapedstate.qpos[3]
const LAYING_QPOS=[-0.164158, 0.0265899, 0.101116, 0.684044, -0.160277,
                   -0.70823, -0.0693176, -0.1321, 0.0203937, 0.298099,
                   0.0873523, 0.00634907, 0.117343, -0.0320319, -0.619764,
                   0.0204114, -0.157038, 0.0512385, 0.115817, -0.0320437,
                   -0.617078, -0.00153819, 0.13926, -1.01785, -1.57189,
                   -0.0914509, 0.708539, -1.57187];
nothing #hide</code></pre><h2 id="Lyceum-API-Simple-Setup-1"><a class="docs-heading-anchor" href="#Lyceum-API-Simple-Setup-1">Lyceum API Simple Setup</a><a class="docs-heading-anchor-permalink" href="#Lyceum-API-Simple-Setup-1" title="Permalink"></a></h2><p>LyceumBase requires access to the underlying simulator, thus any LyceumMuJoCo environments need to point to the correct field in the env struct that is the simulator; in our case here there&#39;s only one field.</p><pre><code class="language-">LyceumMuJoCo.getsim(env::Humanoid) = env.sim</code></pre><p>Normally we could rely on MuJoCo to reset the model to the default configuration when the model XML is loaded; in humanoid.xml&#39;s case, it is in a vertical position. To reset the model to our laying down or supine pose, we can copy in the data from the const array above to <code>d.qpos</code>. Calling <code>forward!</code> here is the same as <code>mj_forward(m,d)</code>, for a pure MuJoCo reference.</p><pre><code class="language-">function LyceumMuJoCo.reset!(env::Humanoid)
    reset!(env.sim)
    env.sim.d.qpos .= LAYING_QPOS
    forward!(env.sim)
    env
end</code></pre><p>This reward function uses the <code>_getheight</code> helper function above to get the model&#39;s height when the function is called. We also specify a target height of 1.25, and penalize the agent for deviating from the target height. There is also a small penalty for using large control activations; if the coefficient is made larger, the agent may not move at all!</p><pre><code class="language-">function LyceumMuJoCo.getreward(state, action, obs, env::Humanoid)
    height = _getheight(statespace(env)(state), env)
    target = 1.25

    reward = 1.0
    if height &lt; target
        reward -= 2.0*abs(target - height)
    end

    reward -= 1e-3*norm(action)^2

    return reward
end</code></pre><p>Finally, we can specify an evaluation function. The difference between the eval and reward functions are that we can track a useful value, such as height with <code>geteval</code>, but an algorithm like MPPI or NPG may need a shaped function to guide any optimization. Plotting this eval function will show the agent&#39;s height over time: this is very useful for reviewing actual desired behavior regardless of the reward achieved, as it can be used to diagnose reward specification problems. The function signature isn&#39;t typed to allow for flexibility with algorithms. In this case, because we know what data we will extract, we can specify that there are two <code>Any</code> type inputs that are not labelled just to match the function signature.</p><pre><code class="language-">function LyceumMuJoCo.geteval(state, ::Any, ::Any, env::Humanoid)
    return _getheight(statespace(env)(state), env)
end</code></pre><h2 id="Running-Experiments-1"><a class="docs-heading-anchor" href="#Running-Experiments-1">Running Experiments</a><a class="docs-heading-anchor-permalink" href="#Running-Experiments-1" title="Permalink"></a></h2><p>Julia performs better when functions are well scoped. Here we construct the MPPI and ControllerIterator objects within a function so they are not global. The MPPI struct accepts an environment constructor and algorithm parameters, and runs the controller. Putting the algorithm in a function allows a user to quickly iterate through parameter searching, or using packages such as <code>Revise</code> can seemlessly allow for reloading of algorithms in development.</p><pre><code class="language-">function hmMPPI(etype=Humanoid; T=200, H=64, K=64)
    env = etype()

    # The following parameters work well for this get-up tasks, and make work for
    # other similar tasks, but is not invariant to the model.
    mppi = MPPI(
                env_tconstructor = i -&gt; tconstruct(etype, i),
                covar0 = Diagonal(0.05^2*I, size(actionspace(env), 1)),
                lambda = 0.4,
                H = H,
                K = K,
                gamma = 1.0
               )

    iter = ControllerIterator(mppi, env; T=T, plotiter=div(T, 10))
    # We can time the following loop; if it ends up less than the time the
    # MuJoCo models integrated forward in, then one could conceivably run this
    # MPPI MPC controller interactively...
    @time for (t, traj) in iter
    end

    savepath = &quot;/tmp/opt_humanoid.jlso&quot;
    exper = Experiment(savepath, overwrite=true)
    exper[:etype] = etype

    for (k, v) in pairs(iter.trajectory)
        exper[k] = v
    end
    finish!(exper)

    return mppi, iter
end

m, d = hmMPPI()</code></pre><h2 id="Checking-Results-1"><a class="docs-heading-anchor" href="#Checking-Results-1">Checking Results</a><a class="docs-heading-anchor-permalink" href="#Checking-Results-1" title="Permalink"></a></h2><p>The MPPI algorithm, and any that you develop, can and should use plotting tools to track progress as they go. IF one wanted to review the results after training, or prepare plots for presentations, one can load the data from disk instead.</p><pre><code class="language-">x = JLSO.load(&quot;/tmp/opt_humanoid.jlso&quot;) # one can load the results as such
plot!(plot(d.trajectory.rewards, label=&quot;Inst. Reward&quot;, title=&quot;Humanoid Standup&quot;),
      d.trajectory.evaluations, label=&quot;Evaluation&quot;)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../visualize/">« Visualizing Results</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 13 January 2020 03:01">Monday 13 January 2020</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
